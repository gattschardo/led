% -*- mode: Noweb; noweb-code-mode: erlang-mode -*-

\documentclass{scrartcl}
\usepackage{noweb}

\title{led - Literate [[ed]]}
\author{Richard ``[[gattschardo]]'' Molitor}
\date{June 19, 2011 - \today} % this will eventually make sense

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}

Welcome to [[led]]! First, let's make clear what [[led]] is - it stands for
``literate [[ed]]'', where [[ed]] of course is the name of the standard text
editor (on \textsc{Unix} anyways). So [[led]] is just a clone of the original
[[ed]] -- whether it ever becomes fully functional only the future will show.

However it's not the primary goal of [[led]] to become a fully operational
[[ed]] clone, -- use the \textsc{Gnu} or some \textsc{Bsd} variant for that. So,
what is the purpose of this thing? This is where the ``literate'' part comes in:
It's just an experiement with literate programming -- I want to see whether this
approach to programming works out for me or not. Also, [[led]] is meant to teach
me some more things about [[ed]] itself (which is a quite nice
program)\footnote{To be true to my own word, I should actually be writing this
in [[ed]], but well, shame on me, looks like I'll be using \textsc{Vim},
mainly for its nice [[make]] integration}, and also about programming in
Erlang, since that is the language in which it is implemented. Especially, one
of the goals is to figure out [[yecc]], the Erlang version of the well known
[[yacc]] parser generator.

%\newpage

\section{The Big Picture}

Since [[ed]] is a fairly simple program (which is of course among the reasons
I choose it for this experiement), it is split into five parts, each of which
is then described in it's own section:

\begin{description}

\item 	[the scanner]
tokenizes the input for the parser.
<<scanner head>>=
-module(ed_scanner).

-compile(export_all).
@

\item	[the parser]
will parse lines of input into an abstract syntax representation (generated
from [[yecc]] grammar).

\item	[the buffer]
is the abstract data structure modeling the edit buffer, supporting operations
such as [[get]], [[append]] and [[change]].
<<buffer head>>=
-module(ed_buffer).

-compile(export_all). % debug only
@

\item 	[main]
will do the rest, that is, reading and writing buffers to file, initializing
the parser and buffer, shutting everything down
<<main head>>=
-module(ed_main).

-compile(export_all).% as above
@

\item	[the startup script]
will start the Erlang VM and pass in the command line arguments (like, the
file name) to main.
<<script head>>=
#!/bin/sh
@

\end{description}

\section{The Scanner}

The scanner must tokenize the input coming from an input port into an array
containing tuples of the form [[{Category, Line, Symbol}]] or, in case of
one-element categories [[{Symbol, Line}]].

At first I believed that I could get away with using the
[[scan_erl_form]] from the [[io]] module and post-processing it's
output a bit, but this is not going to work well, because I cannot
have whitespace filtered out in regular expressions, for example.

So, now there is my own (which always only reads from \textit{stdin},
but that should be fine for [[ed]].

<<scan>>=
scan() ->
    case io:get_line( "led> " ) of
	eof ->
	    {eof, 1};
	{ error, Reason } ->
	    { error, Reason, 1 };
	Line ->
	    %io:format( "Lexing ~s~w",[ Line ]),
	    { ok, lex( Line ), 1 }
    end.
@

Handle some error conditions, or else [[lex]] tokens, when you get them.

<<lex>>=
lex( Tokens ) ->
    lex( Tokens, []).

lex( [], Result ) ->
    lists:reverse( Result );
lex( [ Token | Ts ]= In, Result ) ->
    Digit = is_digit( Token ),
    Special = is_special( Token ),
    Print = is_print( Token ),
    White = is_whitespace( Token ),
    if
	Digit ->
	    { Int, Rest } = string:to_integer( In ),
	    lex( Rest,[{ integer, 1, Int }| Result ]);
	Special ->  
	    lex( Ts,[{ list_to_atom([ Token ]), 1 }| Result ]);
	Print ->
	    lex( Ts,[{ print, 1, Token }| Result ]);
	White ->
	    lex( Ts,[{ whitespace, 1, Token }| Result ]);
	true ->
	    lex( Ts,[{ letter, 1, Token }| Result ])
    end.
@

When we find a digit, we can simply let [[string:to_integer/1]] do the
conversion work, since it conveniently spits out the rest of the
string after the end of our integer.

Now, of course, we need to tell what a digit is -- for this it simply
suffices to check the ascii codes for 0 and 9 for now (Erlang has no
representation for single characters, so I'm giving their numeric
values, 48 and 57).

<<lex>>=
is_digit(Char) ->
    if
	Char >= 48, Char =< 57 ->
	    true;
	Char < 48; Char > 57 ->
	    false
    end.
@ 

This is a mighty ugly scanner. It has lousy performance, too:

<<lex>>=
is_special( 44 ) -> % ,
    true;
is_special( 10 ) -> % \n
    true;
is_special( 46 ) -> % .
    true;
is_special( 36 ) -> % $
    true;
is_special( _ ) ->
    false.

is_whitespace( 9 ) -> % \t
    true;
is_whitespace( 32) -> % space
    true;
is_whitespace( _ ) -> 
    false.

is_print( 112 ) -> % p
    true;
is_print( _ ) ->
    false.
@ 

Empty list means we're done, the [[p]] will be recognized as print
action, everything else will just be passed through.

<<[[ed_scanner.erl]]>>=
<<scanner head>>
<<scan>>
<<lex>>
@

\section{The Parser}

Ok, so let's start defining the grammar for the parser. Of course, in practice
it may not be very rewarding to write a grammar for [[ed]] input, since it's
not very complex and a hand-coded parser should work fine. But remember, I'm
trying to learn \textsc{Yecc}, here\footnote{Also note that Pippijn says a formal
grammar is always a good thing to have, since it will always be easier to
maintain than a hand-written parser}.

The terminal symbols for the grammar are as follows:

<<parser terminals>>=
Terminals ',' '\n' 'integer' '.' '$' 'print'.
@

Note that [[integer]] and [[atom]] are provided by [[erl_scan]] and are simply
Erlang integers resp. atoms.

The nonterminals that we will need are the following

<<parser nonterminals>>=
Nonterminals commands command action region print_act.
@

We will of course be parsing commands one by one, but in non-interactive mode
there can of course be several at once:

<<parser root>>=
Rootsymbol commands.
@

Actually, this might not be what I need, though, the question is how the
parsing works, that is, whether is parses incomplete input. If not, I'll need
to restart a new parser for each command, and then of course, the root symbol
can just be [[command]] instead of [[commands]].

To get a general idea how \textsc{Yecc} input looks like, here is the print
action:

<<parser print>>=
print_act ->
	region 'print' :
	[print, '$1'].
@

<<parser top>>=
commands ->
	commands command :
	['$2'|'$1'].
commands ->
	command :
	'$1'.

command ->
	action '\n' :
	'$1'.
command ->
	action :
	'$1'.

action ->
	print_act :
	'$1'.

region ->
	'integer' ',' 'integer' :
	[region, '$1', '$2', '$3'].
region ->
	'integer' :
	[region, '$1'].
region ->
	'.' :
	[region, '$1'] .
region ->
	'$' :
	[region, '$1'] . %$
@

So, all in all, the parser becomes:
<<[[ed_parser.yrl]]>>=
<<parser nonterminals>>
<<parser terminals>>
<<parser root>>
<<parser top>>
<<parser print>>
@

\section{The Buffer Data Structure}

<<[[ed_buffer.erl]]>>=
<<buffer head>>
@

\section{The Main Module}

For now, the main module just parses lines of input and either prints
the resulting syntax tree, or exits.

<<main parse>>=
start() ->
    loop().

loop() ->
    case step() of
	true ->
	    loop();
	false ->
	    "Bye"
    end.

step() ->
    { ok, T, 1 }= ed_scanner:scan(),
    case ed_parser:parse( T ) of
	{ ok, S } ->
	    io:format( "S-Tree: ~w~n",[ S ]),
	    true;
	{ error,{ _Line, ed_parser,[ Err, Message ]}} ->
	    io:format( "~s~s~n",[ Err, Message ]),
	    false
    end.
@ 

<<[[ed_main.erl]]>>=
<<main head>>
<<main parse>>
@

\section{The Startup Script}

Just start the main method (without passing any arguments, for now).

<<[[led.sh]]>>=
<<script head>>

echo "Hello, led!"
erl -noshell -pa ~/code/led -s ed_main start -s init stop
@

\section{Conclusion}

It's fun, try it!

\section{Defined Chunks}

\nowebchunks

%\section{Index}
%
%\nowebindex

\end{document}

% vim: se tw=78:
